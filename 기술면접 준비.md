# :pencil2: 주니어 개발자 면접 예상 질문
</br>

## Java

### :heavy_check_mark: **자바의 특징**

- 객체 지향 언어로써 캡슐화, 상속, 다형성 기능을 지원합니다.
- JVM 위에서 동작하기 때문에 OS에 종속적이지 않아 독립적으로 작동하여 이식성이 높습니다.
- GC(Garbage Collection, 가비지 컬렉션)에 의한 메모리 자동 관리
- 멀티 스레드를 쉽게 구현할 수 있습니다.
- 동적 로딩을 지원합니다.
</br>

### :heavy_check_mark: **클래스, 객체, 인스턴스**

  - **클래스**   
    \- 객체를 만들기 위한 설계도입니다.  
    \- 객체의 속성을 나타내는 필드(Field)와 동작을 나타내는 메소드(Method)로 구성됩니다.  
  - **객체**  
    \- 클래스를 이용해 만들어낸 실체입니다.  
  - **인스턴스**  
    \- 객체가 메모리에 올라간(할당된) 클래스를 뜻합니다.  
    \- new 라는 키워드를 사용해서 클래스를 메모리에 올립니다.  
</br>    

### :heavy_check_mark: **접근 제한자**

  - **public**    
    \- 모든 클래스든 접근을 허용합니다. 
  - **protected**   
    \- 같은 패키지인 경우만 접근 허용. 단, 다른 패키지라도 상속받은 자식 클래스에서는 접근 가능합니다. 
  - **default**   
    \- 자기 자신과 같은 패키지 안에서만 접근 허용합니다. 
  - **private**  
    \- 자기 자신만 접근할 수 있습니다.  
  - 접근 제한자의 범위 순서 : [`public > protected > default > private`]()      
</br>  

### :heavy_check_mark: **객체 지향 프로그래밍 특징**

  - **객체 지향 프로그래밍(Object-Oriented Programming)이란?**   
    \- 프로그래밍에서 필요한 데이터를 추상화시켜 '객체'라는 기본 단위로 정의하고, 객체를 중심으로 프로그래밍 하는 것.  
   
  - **캡슐화**   
    \- 객체의 필드와 메서드를 하나로 묶고, 실제 구현 내용을 감추는 것입니다. 이를 통해 은닉 효과를 얻을 수 있습니다.  
    \- 접근 제한자를 통해 객체의 필드와 메서드의 사용 범위를 제한함으로써 외부로부터 보호합니다.   
  - **추상화**  
    \- 사물들의 공통적인 특징을 파악해서 하나의 개념으로 다루는 것을 뜻합니다.
  - **다형성**  
    \- 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 사용할 수 있도록 해줍니다.   
    \- 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용합니다.
  - **상속성**  
    \- 상위 객체의 필드와 메서드를 하위 객체에 물려주어 하위 객체에서 사용할 수 있도록 해줍니다.      
</br>  

### :heavy_check_mark: **replaceAll("[a-zA-Z]","").toUpperCase()**
  - **\[a-zA-Z]\(정규식)**   
    \- a-z, A-z까지 정규표현식(Regex)
    
  - **toUpperCase()**    
    \- toUpperCase() 메서드는 문자열을 대문자로 변환한 값을 반환합
</br>

### :heavy_check_mark: **Overloading vs Overriding**  
  - **Overloading**    
    \- 매개변수의 개수나 자료형을 다르게하여 같은 이름의 메소드를 사용할 수 있습니다. 
    
  - **Overriding**    
    \- 상속받은 클래스에서 같은 이름의 메소드를 재정의하는 것을 뜻합니다. 
</br>

### :heavy_check_mark: **Call by Value vs Call by Reference**  
  - **Call by Value**   
    \- 값에 의한 호출을 의미합니다.   
    \- 전달받은 값을 복사하여 처리하기 때문에 전달받은 값이 변경되어도 원본의 값이 변경되지 않습니다.  
    `정리` Call by value는 메서드 호출 시에 사용되는 인자 값의 메모리에 저장된 값(value)을 복사하여 보낸다.
    
  - **Call by Reference**   
    \- 참조에 의한 호출을 의미합니다.   
    \- 전달받은 값을 직접 참조하기 때문에 값이 변경되면 원본도 같이 변경됩니다.   
    `정리` Call by reference는 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어있는 주소(Address)를 복사하여 보낸다.    
</br>

### :heavy_check_mark: **extends vs implement**  
  - **extends(상속)**     
    \- extends 키워드를 사용하여 부모 클래스를 상속받아 자식 클래스에서 부모 클래스가 가진 것을 사용할 수 있습니다.  
    \- 부모가 가진 것을 자식에게 물려주는 것을 is a 혹은 kind of 관계라고 부릅니다.  
 
  - **implement(구현)**  
    \- 인터페이스를 상속받아 기능을 재정의(Overriding)하는 것입니다.
</br>

## WEB

### :heavy_check_mark: **Session vs Cookie**   

   - **Session와 Cookie 차이점**      
      \- **클라이언트의 정보가 저장되는 위치, 저장형식, 만료시점 등**이 다릅니다.  
      `정리` 저장 위치 : 쿠키는 클라이언트의 브라우저 메모리에 저장 또는 파일에 저장하고, 세션은 서버 메모리에 저장합니다.   
      `정리` 만료 시점 : 쿠키는 정해진 사용자 유효 시간까지 브라우저 인증 유지, 세션은 접속 시간에 따른 일정한 시간에 응답이 없으면 연결을 끊습니다. 
      
  - **Session와 Cookie 사용 이유?**       
      \- HTTP의 비연결성(Connectionless)와 무상태(Stateless)이라는 특징을 보안하기 위해 사용합니다.   
      `정리` **클라이언트의 정보를 유지**하기 위해 사용하는 것이 쿠키와 세션입니다.    
      
    ##### **[`+여기서 잠깐`]() 비연결성(Connectionless)**   
        - HTTP는 클라이언트가 요청(Request)을 보내고, 서버는 클라이언트에게 응답(Response)을 주면 연결을 끊는 특성이 있습니다.  

    ##### **[`+여기서 잠깐`]() 무상태(Stateless)**     
        - 연결을 끊는 순간 클라이언트와 서버의 통신도 끝나며, 상태 정보를 유지하지 않는 특성이 있습니다.  
      
  - **Cookie(쿠키)**   
    \- 사용자에 대한 정보를 접속자 PC에 저장합니다.    
    \- 사용자 인증 유효 시간이 정해지면 브라우저를 종료되어도 인증이 유지된다.  
    \- 사용자 로컬 PC에 저장되는 키와 값(Key, Value)이 들어있는 작은 데이터 파일입니다.   
    \- 세션 쿠키(Session Cookie)와 지속 쿠키(Persistent Cookie)로 나뉩니다.    

    ##### **[`+여기서 잠깐`]() 세션 쿠키(Session Cookie)**     
        - 유효시간을 지정하지 않으면 브라우저 메모리에 저장되므로, 브라우저가 종료되면 쿠키는 사라집니다. 

    ##### **[`+여기서 잠깐`]() 지속 쿠키(Persistent Cookie)**  
        - 유효시간을 지정하면 파일로 저장되어 특정 날짜(기간)까지 유효하므로, 브라우저가 종료되어도 쿠키는 남아 있습니다.   
        
    ##### **[`+여기서 잠깐`]() 구성 요소**    
        - 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름    
        - 값 : 쿠키가 갖고 있는 값    
        - 유효시간 : 쿠키가 유지되는 시간    
        - 도메인 : 쿠키를 전송할 도메인    
        - 경로 : 쿠키를 전송할 요청 경로    
         
    ##### **[`+여기서 잠깐`]() Cookie 동작 방식?**  
        1. 클라이언트가 웹 페이지를 요청합니다. 
        2. 웹 서버는 Session ID를 발급합니다.
        3. 생성한 쿠키에 정보를 담아 HTTP화면을 돌려줄 때, 같이 클라이언트에게 돌려줍니다.
        4. 넘겨 받은 쿠키를 클라이언트 로컬 PC의 쿠키 저장소에 저장합니다. (이때 쿠키 이름 JSESSIONID) 
        5. 다시 웹 서버에 요청할 때 요청과 함께 Request-Header에 쿠키 값을 넣어 전송합니다.
  
    ##### **[`+여기서 잠깐`]() Cookie 사용 예시?**    
        - 방문 사이트 로그인 시, "자동 로그인" , "아이디와 비밀번호를 저장하시겠습니까?"  
        - 팝업창에서 "오늘 더 이상 이 창을 보지 않음" 체크     
        - 쇼핑몰 장바구니 기능    
        
  - **Session(세션)**  
    \- 세션은 쿠키를 기반으로, 사용자에 대한 정보를 **웹 서버 측에 저장**합니다.  
    \- 사용자에 대한 정보를 웹 서버에 두기 때문에 **보안면에서는 쿠키보다 우수**합니다.    
    \- 클라이언트를 구분하기 위해 Session ID를 부여하여 **브라우저가 종료할 때까지 인증 상태를 유지**해줍니다.    
    \- 단, **접속 시간에 제한**을 두어 일정 시간 응답이 없으면 연결을 끊도록 설정 가능합니다.  
    
    ##### [`+여기서 잠깐`]() Session 동작 방식?
        1. 클라이언트가 웹 페이지에 요청합니다.
        2. 클라이언트가 요청한 Request-Header에 Cookie 확인하여 Session ID 유무를 확인합니다.
        3. Session ID가 존재하지 않다면, Session ID를 생성해 클라이언트로 돌려줍니다.
        4. 클라이언트로 돌려줄 때, Response-Header의 Cookie에 Session ID를 저장해서 보냅니다.
        5. 클라이언트는 Session ID를 Cookie 저장소에 저장합니다. (이때 쿠키 이름 JSESSIONID) 
        6. 클라이언트가 서버에 다시 접속 시 Request-Header의 Cookie(JSESSION)를 이용하여 Session ID값을 서버에 전달합니다.

    ##### [`+여기서 잠깐`]() Session 사용 예시? 
        - 화면을 이동해도 로그인이 유지됩니다.        
        
</br> 

### :heavy_check_mark: **HTTP Server(Web Server) vs WAS(Web Application Server)**
  
  - Web Server와 WAS의 겹치는 역할도 있지만, 각자 특화된 부분들을 활용해서 보안/운영에  Web Server가 담당하며
  WAS는 동적요소를 만드는데 집중하는 차이가 있습니다.
  
  - **HTTP Server(Web Server)**  
    \- 개념 소프트웨어와 하드웨어로 구분됩니다.   
    \- 대표적인 예로 Apache Web Server, IIS, NginX 등이 있습니다.  
    
    \- **1) 소프트웨어**    
      \- 웹 브라우저의 요청을 받아들여서 이에 알맞은 결과를 웹 브라우저에 응답해주는 역할입니다.   
      \- 정적인 처리 및 가벼운 동적 리소스 제공 역할을 합니다.  
      \- 요청에 따라 필요한 페이지의 로직이나 데이터베이스 연동을 위해서 애플리케이션 서버에 처리를 요청합니다.  
      \- Reverse Proxy 보안 기능, 로드 밸런싱 다수 User 분산 처리, 캐싱 등 보안 및 트래픽 처리를 담당합니다.  
      
    \- **2) 하드웨어**   
      \- Web Server가 설치되어 있는 컴퓨터 

  - **WAS(Web Application Server)**   
    \- 웹브라우저로부터 웹 서버가 요청을 받으면 그 요청을 받아 로직 처리의 결과를 웹 서버로 다시 반환해주는 소프트웨어입니다.   
    \- 웹 서버와 DBMS 사이에 동작하는 미들웨어로써, 컨테이너 기반으로 동작합니다.   
    \- 흔히 컨테이너, 웹 컨테이너, 서블릿 컨테이너로 부릅니다.    
    \- 대표적인 예로 Apache Tomcat, Jetty(Eclipse), WEbLogic(Oracle), Jeus(WebToB), JBoss(Red Hat) 등이 있습니다.     
    
    ##### **[`+여기서 잠깐`]() 컨테이너란?**     
        - JSP, Servlet을 실행시킬 수 있는 소프트웨어    
       
    ##### **[`+여기서 잠깐`]() 웹 컨테이너란?**    
        - 클라이언트 요청을 내부 로직을 통해 결과를 처리하고 동적 컨텐츠를 생성해 클라이언트에게 응답 해주는 역할을 수행.      
</br>


### :heavy_check_mark: **MVC1 vs MVC2**  

  - **MVC란?**     
    \- Model-View-Controller의 약자로 3가지 형태로 역할을 나누어 개발하는 방법론입니다.  
    \- 사용자 인터페이스와 비지니스 로직 처리를 분리시켜 서로 영향 없이 개발하기 수월하다는 장점이 있습니다.  
    
    ##### **[`+여기서 잠깐`]() Model(저장)**  
        - 어플리케이션에서 처리된 데이터, 자료를 의미합니다.  
        - DB에서 처리된 결과 데이터를 가진 객체입니다.  

    ##### **[`+여기서 잠깐`]() View(표현)**  
        - 사용자가 보게 될 결과 화면으로 유저 인터페이스(UI)를 의미합니다.   
        - 클라이언트 측 기술인 html,css,js 등을 모아둔 컨테이너 입니다.  

    ##### **[`+여기서 잠깐`]() Controller(처리)**    
        - Model과 View를 이어주는 브릿지 역할을 의미합니다.  
        - 사용자가 접근한 URL에 따른 요청사항을 처리 후, Model에서 나온 결과 데이터를 View에 반영하여 사용자에게 알려줍니다.  
  
  - **MVC1**  
    \- 모든 요청과 응답을 jsp가 담당하는 구조입니다.  
    \- jsp페이지 안에서 모든 정보를 표현(view), 처리(Controller), 저장(Model)합니다.  
    \- 복잡해지면 유지보수에 용이하지 않습니다.   
    
  - **MVC2**   
    \- 클라이언트 요청을 Servlet이 받아 알맞게 처리 후, jsp페이지로 결과를 전달합니다.  
    \- 클라이언트의 요청, 비니지스 로직 처리, 응답 부분을 모듈화한 구조입니다.  
    \- 처리작업의 분리로 유지보수 및 확장에 용이하지만, 구조 설계를 위한 시간이 필요합니다.  
</br>

### :heavy_check_mark: **Framework**  
- 어떤 프로그램을 만들기 위한 기본 구조(뼈대, 틀) 이라고 합니다.  
- 기본적으로 필요한 기능을 갖추고 있어 개발에 용이합니다.  

  ##### **[`+여기서 잠깐`]() Framework와 Library 차이는?**  
      - Framework : 내가 개발하기 위해 지켜야 하는 구조  
      - Library : 내가 개발하기 위해 필요한 것들이 이미 구현되어 있는 대상  
</br>

### :heavy_check_mark: **DI(Dependency Injection)**   
- 각 객체 간의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 매핑시켜줍니다. 
- 필요한(의존하는) 클래스를 직접 생성하는 것이 아닌, 주입해줌으로써 객체 간의 결합도를 줄이고 좀 더 유연한 코드를 작성할 수 있게됩니다. 
</br>

### :heavy_check_mark: **JSON 타입**  
  - **JSON(JavaScript Object Notation)**  
    \- 키-값이 쌍으로 이루어진 개방형 표준 데이터 포맷입니다. (데이터 교환 형식)         
    \- 비동기 브라우저/서버 통신(ajax)을 위해 사용하는 데이터 포맷입니다.   
    \- JavaScript에서 ajax 비동기 통신시 xmlHTTPRequest에 json형태의 데이터로 객체에 담아서 보냄     
    \- 보통 RESTful API, Open API 에서 json 형태의 데이터를 주고 받습니다.      
    `정리` key-value 형식으로 데이터를 주고 받을 때 사용하는 데이터 포맷 형식입니다. {"key" : "value"}  

    ##### [`+여기서 잠깐`]() ajax란?  
        - 페이지 새로고침 없이 서버에 요청을 할 수 있습니다.  
        - 서버로부터 데이터를 받고 작업을 수행할 수 있습니다. 
      
    ##### [`+여기서 잠깐`]() RESTful API란?  
</br>

## NETWORK

### :heavy_check_mark: **HTTP vs HTTPS 차이는** 

  - **HTTP(Hyper Text Transfer Protocol)**     
    \- 클라이언트와 서버 사이에 데이터를 주고 받는 프로토콜(통신규약) 입니다.(80번 포트 사용) 
    
  - **HTTPS (Hyper Text Transfer Protocol Secure)**        
     \- HTTP에 데이터 암호화가 추가된 프로토콜 입니다.(433번 포트 사용) 
  
  - **HTTP와 HTTPS 차이?**  
     \- HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면에 HTTPS는 안전하게 데이터를 주고 받을 수 있습니다.     
     \- HTTPS를 이용하면 암호화/복호화의 과정이 필요로 하며, 공개키/개인키 인증서를 발급하고 유지하기 위한 추가 비용이 발생합니다.    

     ##### **[`+여기서 잠깐`]() HTTPS 사용하는 이유?**      
        - HTTP는 암호화 되지 않은 평문 데이터를 전송하기 때문에 개인정보를 주고 받으면 제 3자가 정보를 알 수 있게 됩니다.  
        - 문제 해결을 위해 네트워크 상 중간에 제 3자가 정보를 볼 수 없게 공개키 암호화를 지원하는 SSL프로토콜을 사용합니다. 

     ##### **[`+여기서 잠깐`]() SSL(Secure Socket Layer) 프로토콜**  
        - 브라우저와 서버 사이에 전송된 데이터를 암호화하여 인터넷 연결에 보안성을 유지해주는 기술입니다.  
        - 클라이언트와 서버간 공유하는 암호화키를 가지고 암호회된 데이터가 송수신 되는 방식  
</br>
