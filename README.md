# 👩🏻‍🏫 주니어 개발자 면접 예상 질문
</br>

## Java

### :heavy_check_mark: **자바의 특징**

- 객체 지향 언어로써 캡슐화, 상속, 다형성 기능을 지원합니다.
- JVM 위에서 동작하기 때문에 OS에 종속적이지 않아 독립적으로 작동하여 이식성이 높습니다.
- GC(Garbage Collection, 가비지 컬렉션)에 의한 메모리 자동 관리
- 멀티 스레드를 쉽게 구현할 수 있습니다.
- 동적 로딩을 지원합니다.
</br>

### :heavy_check_mark: **클래스, 객체, 인스턴스**

  - **클래스**   
    \- 객체를 만들기 위한 설계도입니다.  
    \- 객체의 속성을 나타내는 필드(Field)와 동작을 나타내는 메소드(Method)로 구성됩니다.  
  - **객체**  
    \- 클래스를 이용해 만들어낸 실체입니다.  
  - **인스턴스**  
    \- 객체가 메모리에 올라간(할당된) 클래스를 뜻합니다.  
    \- new 라는 키워드를 사용해서 클래스를 메모리에 올립니다.  
</br>    

### :heavy_check_mark: **접근 제한자**

  - **public**    
    \- 어디서든 자유롭게 접근이 가능합니다.
  - **protected**   
    \- 같은 패키지인 경우만 접근 허용. 단, 다른 패키지라도 상속받은 자식 클래스에서는 접근 가능합니다. 
  - **default**   
    \- 자기 자신과 같은 패키지 안에서만 접근 허용합니다. 
  - **private**  
    \- 자기 자신만 접근할 수 있습니다.  
  - 접근 제한자의 범위 순서 : [`public > protected > default > private`]()      
</br>  

### :heavy_check_mark: **객체 지향 프로그래밍 특징**

  - **객체 지향 프로그래밍(Object-Oriented Programming)이란?**   
    \- 프로그래밍에서 필요한 데이터를 추상화시켜 '객체'라는 기본 단위로 정의하고, 객체를 중심으로 프로그래밍 하는 것.  
   
  - **캡슐화**   
    \- 객체의 필드와 메서드를 하나로 묶고, 실제 구현 내용을 감추는 것입니다. 이를 통해 은닉 효과를 얻을 수 있습니다.  
    \- 접근 제한자를 통해 객체의 필드와 메서드의 사용 범위를 제한함으로써 외부로부터 보호합니다.   
  - **추상화**  
    \- 사물들의 공통적인 특징을 파악해서 하나의 개념으로 다루는 것을 뜻합니다.
  - **다형성**  
    \- 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 사용할 수 있도록 해줍니다.   
    \- 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용합니다.
  - **상속성**  
    \- 상위 객체의 필드와 메서드를 하위 객체에 물려주어 하위 객체에서 사용할 수 있도록 해줍니다.      
</br>  

### :heavy_check_mark: **객체지향 프로그램이 5대 원칙(SOLID)**

  - **단일 책임 원칙(SRP, Single Responsiblity Principle)**    
    \- 역할(책임)을 분리 하는 것.  
    \- 어떤 클래스를 변경해야하는 이유는 오직 하나뿐이어야 한다. 
  
  - **개방-폐쇄 원칙(OCP, Open-Closed Principle)**  
    \- 클래스, 모듈, 함수 등 확장에 대해서는 열려 있어야 하지만, 변경에 대해서는 닫혀 있어야 합니다.  
    \- 이를 위해 인터페이스를 사용하기도 합니다.  
    \- 예) 데이터베이스 프로그래밍을 지원하는 lib, Framework  
    \- 예) JVM, os의 변환에 닫혀있고, 각 os별 JVM은 확장에 열려 있는 구조  

  - **리스코프 치환 원칙(LSP, Liskov Substitution Principle)**   
    \- 하위클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.  
    \- 계층형 x, 분류도 o  
    
  - **인터페이스 분리 원칙(ISP, Interface Segregation Principle)**    
    \- 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다.  
    \- 작은 단위로 인터페이스를 분리시키고, 꼭 필요한 메서들만 사용하여 내부 의존성 관계를 느슨하게 한다.  
    \- 인터페이스는 is able to(~할 수 있는)  

  - **의존 역적 원칙(DIP, Dependency Inversion Principle)**  
    \- 구체적인 클래스보다는 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 영향을 받지 않게 하는 것.  

### :heavy_check_mark: **결합도와 응집도**

  - **결합도**  
    \- 모듈(클래스)간의 상호 의존 정도로서 결합도가 낮으면 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이해집니다.    
    
  - **응집도**  
    \- 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이해집니다.  
</br> 

### :heavy_check_mark: **디자인 패턴** 
  - **싱글톤(Signleton)**    
    \- 클래스의 인스턴스 즉, 객체를 하나만 만들고 그것을 계속해서 재사용하는 패턴.  
    
  - **템플릿 메서드 패턴(Template Method Pattern)**    
    \- 상위클래스 견본 메소드에서 하위클래스가 오버라이딩한 메소드를 호출하는 패턴  
  
  - **팩토리 메서드 패턴(Factory Method Pattern)**    
    \- 오버라이딩된 메서드가 객체를 반환하는 패턴      
</br> 

### :heavy_check_mark: **JVM(Java Virtual Machine)**

  - **JVM이란?**    
    \- 바이트 코드 파일을 해당 운영체제에서 실행 가능한 기계어로 변역 후 실행할 수 있게 해주는 가상의 운영체제입니다.  
    \- 운영체제의 종류와 무관하게 동일한 동작을 보장합니다.  
    \- GC에 의해 메모리 관리를 수행합니다.  
    \- 스택 기반의 가상머신입니다.  
    
  - **JVM구성**  
    \- 3개의 서브시스템으로 구성되어 있습니다.       
    \- 클래스 로더(Class Loader)       
    \- Runtime Data Areas   
    \- 실행 엔진(Excution Engine), Garbage Collector      
    
  - **실행과정**  
   1. 프로그램이 실행되면 JVM은 OS로부터 메모리를 할당 받는다.
   2. 컴파일러가 소스코드(.java)를 읽어 바이트코드(.class)로 변환시킨다.
   3. 클래스 로더를 통해 class파일들을 JVM에 로딩시킨다.
   4. 실행 엔진을 통해 로딩된 class파일들을 해석한다.
   5. 해석된 바이트코드는 Runtime Data Areas에 배치된 후 실행된다.  

<img src="https://user-images.githubusercontent.com/28051638/123572486-45105100-d807-11eb-8eec-0c91062263d7.png"  width="80%" alt="jvm"></img>
  
  - **ref**  
  https://icarus8050.tistory.com/56

</br>

### :heavy_check_mark: **Garbage Collection**
  - 자바 메모리 관리 기법 중 하나 입니다. 
  - JVM GC를 이용해 동적으로 할당했던 메모리 영역 중 필요없게 된 객체를 메모리에서 자동으로 제거해줍니다.

    [`+여기서 잠깐`]() 동적할당이란?  
    \- 컴퓨터 프로그래밍 실행 시간 동안 **사용할 메모리 공간**을 할당하는 것을 말합니다.  
</br>

### :heavy_check_mark: **자바 메모리 영역(JVM 메모리 영역, Runtime Data Area)**
  
  - **[Runtime Data Area 상세설명](https://github.com/genieeeee/java-concept-summary/blob/main/%5Bjava%5D%20JVM%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EC%82%AC%EC%9A%A9%20%EC%98%81%EC%97%AD.md)** 
  
  - **힙 영역**   
    \- JVM이 구동될 때 생성되며 모든 스레드가 공유하는 영역.      
    \- JVM이 읽어들인 클래스, 인터페이스에 대한 정보, 필드와 메소드, 런타임 풀 상수,  Static 변수, 생성자(Constructor)등 저장   
  - **힙 영역**      
    \- 객체와 배열이 생성되는 영역     
    \- JVM 스택(Stack) 영역에서 생성된 변수나 다른 객체의 필드에서 이 곳에 있는 객체와 배열을 참조한다.    
    \- 참조하는 변수나 필드가 없다면 GC에 의해 자동으로 제거한다.   
  - **스택 영역**  
    \- 메서드가 호출되면, 메서드의 매개변수, 지역변수가 저장되는 영역입니다.   
</br>

### :heavy_check_mark: **Overloading vs Overriding**  
  - **Overloading**   
    \- 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의.    
    \- 매개변수의 개수나 자료형을 다르게하여 같은 이름의 메소드를 여러개 만들 수 있습니다.
    
  - **Overriding**   
    \- 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의.      
    \- 상속받은 클래스나 인터페이스의 메소드를 같은 이름으로 재정의하는 것을 뜻합니다. 
</br>

### :heavy_check_mark: **Call by Value vs Call by Reference**  
  - **Call by Value**   
    \- 값에 의한 호출을 의미합니다.   
    \- 전달받은 값을 복사하여 처리하기 때문에 전달받은 값이 변경되어도 원본의 값이 변경되지 않습니다.  
    `정리` Call by value는 메서드 호출 시에 사용되는 인자 값의 메모리에 저장된 값(value)을 복사하여 보낸다.
    
  - **Call by Reference**   
    \- 참조에 의한 호출을 의미합니다.   
    \- 전달받은 값을 직접 참조하기 때문에 값이 변경되면 원본도 같이 변경됩니다.   
    `정리` Call by reference는 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어있는 주소(Address)를 복사하여 보낸다.    
</br>

### :heavy_check_mark: **extends vs implement**  
  - **extends(상속)**     
    \- extends 키워드를 사용하여 부모 클래스를 상속받아 자식 클래스에서 부모 클래스가 가진 것을 사용할 수 있습니다.  
    \- 부모가 가진 것을 자식에게 물려주는 것을 is a 혹은 kind of 관계라고 부릅니다.  
 
  - **implement(구현)**  
    \- 인터페이스를 상속받아 기능을 재정의(Overriding)하는 것입니다.
</br>

### :heavy_check_mark: **Abstract Class vs Interface**  
  - **Abstract Class**  
    \- 상속을 통해 자식 클래스에서 완성하도록 유도하는 클래스입니다.  
    \- 추상 클래스는 미완성 추상 메소드를 포함할 수 있으며, 추상 메서드가 하나라도 있면 추상 클래스가 되어야 합니다.  
    \- 필드, 생성자, 추상 메서드를 가질 수 있으며, 생성자를 가지기 때문에 객체화가 가능합니다.  
    
    ```java
    abstract class AbstractSample {
        // Field
        private int num;
        
        // Constructor 
        public AbstractSample(int num) {
            this.num = num;
        }
        
        // Abstract Method 	
        public abstract void calc();
    }
    ```    
  - **Interface**  
    \- 다른 클래스에서 인터페이스를 구현하여 타입의 역할로는 가능하다.  
    \- 상수(static, final)와 추상 메서드(abstract method)의 집합입니다.  
    \- 자바8 부터 default, static 메서드를 지원합니다.  
    \- 생성자를 가질 수 없어서 객체화 불가능 합니다.  
    \- 다중 상속이 가능합니다.  
    
    ```java
    interface InterfaceSample {
        public static final int NUM = 10; // public static final 생략 가능. 컴파일 시에 자동 생성
        public abstract void calc(); // public abstract 생략 가능. 컴파일 시에 자동 생성
    }
    ```
</br>    

### :heavy_check_mark: **프로세스(Process)와 스레드(Thread)**

  - **프로세스(Process)**      
    \- 운영체제로부터 자원을 할당받은 작업의 단위입니다.  
    \- 운영체제가 프로세스에게 Code/Data/Stack/Heap 메모리 영역을 할당해주고 최소 작업 단위로 삼는다.  
    
  - **스레드(Thread)**    
    \- 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위입니다.   
    \- 프로세스 내에서 Stack 메모리 영역을 제외한 Code/Data/Heap 다른 메모리 영역을 같은 프로세스 내 다른 스레드와 공유합니다.  
</br>

### :heavy_check_mark: **스레드(Thread)**

  - **Thread클래스와 Runnable인터페이스 차이**  
    \- Thread클래스는 자바에서 다중 상속을 허용하지 않기 때문에 Thread 클래스를 확장하는 클래스는 다른 클래스를 상속받을 수 없습니다.  
    \- 반면에 Runnable 인터페이스를 구현했을 경우에는 다른 인터페이스를 구현할 수 있을 뿐만 아니라, 다른 클래스도 상속받을 수 있습니다.       
    \- 따라서 해당 클래스의 확장성이 중요한 상황이라면 Runnable 인터페이스를 구현하는 것이 더 바람직할 것입니다.   
    \- 실제로 많은 개발자들이 대부분의 상황에서 Thread 클래스를 확장하기보다는 Runnable 클래스를 구현하는 것을 선호합니다.  
</br>

### :heavy_check_mark: **멀티태스킹와 멀티스레드**

  - **멀티태스킹**   
    \- 하나의 운영체제 안에서 여러 프로세스가 실행되는 것입니다.  
    
  - **멀티스레드**      
    \- 하나의 프로세스가 여러 작업을 여러 스레드를 사용해서 동시에 처리하는 것을 의미합니다.  
    
  - **멀티스레드 장점**    
    \- Context Switching할 때 공유하고 있는 메모리만큼의 자원을 아낄 수 있습니다.    
    \- 프로세스 내의 Stack영역을 제외한 모든 메모리를 공유하기 때문에 통신부담이 적어 프로그램 응답 시간이 단축됩니다.    

    ##### **[`+여기서 잠깐`]() Context Switching이란?**   
        - 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고, 다음 진행할 Task의 상태 값을 읽어 적용하는 과정입니다. 
</br> 

### :heavy_check_mark: **JDBC(Java DataBase Connection)**  
- Java언어를 통해 데이터베이스에 접근할 수 있는 프로그래밍을 의미합니다.  
</br>

### :heavy_check_mark: **replaceAll("[a-zA-Z]","").toUpperCase()**
  - **\[a-zA-Z]\(정규식)**   
    \- a-z, A-z까지 정규표현식(Regex)
    
  - **toUpperCase()**    
    \- toUpperCase() 메서드는 문자열을 대문자로 변환한 값을 반환합
</br>


    
    
## WEB

### :heavy_check_mark: **Session vs Cookie**   

   - **Session와 Cookie 차이점**      
      \- **클라이언트의 정보가 저장되는 위치, 저장형식, 만료시점 등**이 다릅니다.  
      `정리` 저장 위치 : 쿠키는 클라이언트의 브라우저 메모리에 저장 또는 파일에 저장하고, 세션은 서버 메모리에 저장합니다.   
      `정리` 만료 시점 : 쿠키는 정해진 사용자 유효 시간까지 브라우저 인증 유지, 세션은 접속 시간에 따른 일정한 시간에 응답이 없으면 연결을 끊습니다. 
      
  - **Session와 Cookie 사용 이유?**       
      \- HTTP의 비연결성(Connectionless)와 무상태(Stateless)이라는 특징을 보안하기 위해 사용합니다.   
      `정리` **클라이언트의 정보를 유지**하기 위해 사용하는 것이 쿠키와 세션입니다.    
      
    ##### **[`+여기서 잠깐`]() 비연결성(Connectionless)**   
        - HTTP는 클라이언트가 요청(Request)을 보내고, 서버는 클라이언트에게 응답(Response)을 주면 연결을 끊는 특성이 있습니다.  

    ##### **[`+여기서 잠깐`]() 무상태(Stateless)**     
        - 연결을 끊는 순간 클라이언트와 서버의 통신도 끝나며, 상태 정보를 유지하지 않는 특성이 있습니다.  
      
  - **Cookie(쿠키)**   
    \- 사용자에 대한 정보를 접속자 PC에 저장합니다.    
    \- 사용자 인증 유효 시간이 정해지면 브라우저를 종료되어도 인증이 유지된다.  
    \- 사용자 로컬 PC에 저장되는 키와 값(Key, Value)이 들어있는 작은 데이터 파일입니다.   
    \- 세션 쿠키(Session Cookie)와 지속 쿠키(Persistent Cookie)로 나뉩니다.    

    ##### **[`+여기서 잠깐`]() 세션 쿠키(Session Cookie)**     
        - 유효시간을 지정하지 않으면 브라우저 메모리에 저장되므로, 브라우저가 종료되면 쿠키는 사라집니다. 

    ##### **[`+여기서 잠깐`]() 지속 쿠키(Persistent Cookie)**  
        - 유효시간을 지정하면 파일로 저장되어 특정 날짜(기간)까지 유효하므로, 브라우저가 종료되어도 쿠키는 남아 있습니다.   
        
    ##### **[`+여기서 잠깐`]() 구성 요소**    
        - 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름    
        - 값 : 쿠키가 갖고 있는 값    
        - 유효시간 : 쿠키가 유지되는 시간    
        - 도메인 : 쿠키를 전송할 도메인    
        - 경로 : 쿠키를 전송할 요청 경로    
         
    ##### **[`+여기서 잠깐`]() Cookie 동작 방식?**  
        1. 클라이언트가 웹 페이지를 요청합니다. 
        2. 웹 서버는 Session ID를 발급합니다.
        3. 생성한 쿠키에 정보를 담아 HTTP화면을 돌려줄 때, 같이 클라이언트에게 돌려줍니다.
        4. 넘겨 받은 쿠키를 클라이언트 로컬 PC의 쿠키 저장소에 저장합니다. (이때 쿠키 이름 JSESSIONID) 
        5. 다시 웹 서버에 요청할 때 요청과 함께 Request-Header에 쿠키 값을 넣어 전송합니다.
  
    ##### **[`+여기서 잠깐`]() Cookie 사용 예시?**    
        - 방문 사이트 로그인 시, "자동 로그인" , "아이디와 비밀번호를 저장하시겠습니까?"  
        - 팝업창에서 "오늘 더 이상 이 창을 보지 않음" 체크     
        - 쇼핑몰 장바구니 기능    
        
  - **Session(세션)**  
    \- 세션은 쿠키를 기반으로, 사용자에 대한 정보를 **웹 서버 측에 저장**합니다.  
    \- 사용자에 대한 정보를 웹 서버에 두기 때문에 **보안면에서는 쿠키보다 우수**합니다.    
    \- 클라이언트를 구분하기 위해 Session ID를 부여하여 **브라우저가 종료할 때까지 인증 상태를 유지**해줍니다.    
    \- 단, **접속 시간에 제한**을 두어 일정 시간 응답이 없으면 연결을 끊도록 설정 가능합니다.  
    
    ##### [`+여기서 잠깐`]() Session 동작 방식?
        1. 클라이언트가 웹 페이지에 요청합니다.
        2. 클라이언트가 요청한 Request-Header에 Cookie 확인하여 Session ID 유무를 확인합니다.
        3. Session ID가 존재하지 않다면, Session ID를 생성해 클라이언트로 돌려줍니다.
        4. 클라이언트로 돌려줄 때, Response-Header의 Cookie에 Session ID를 저장해서 보냅니다.
        5. 클라이언트는 Session ID를 Cookie 저장소에 저장합니다. (이때 쿠키 이름 JSESSIONID) 
        6. 클라이언트가 서버에 다시 접속 시 Request-Header의 Cookie(JSESSION)를 이용하여 Session ID값을 서버에 전달합니다.

    ##### [`+여기서 잠깐`]() Session 사용 예시? 
        - 화면을 이동해도 로그인이 유지됩니다.        
        
</br> 

### :heavy_check_mark: **HTTP Server(Web Server) vs WAS(Web Application Server)**
  
  - Web Server와 WAS의 겹치는 역할도 있지만, 각자 특화된 부분들을 활용해서 보안/운영에  Web Server가 담당하며
  WAS는 동적요소를 만드는데 집중하는 차이가 있습니다.
  
  - **HTTP Server(Web Server)**  
    \- 개념 소프트웨어와 하드웨어로 구분됩니다.   
    \- 대표적인 예로 Apache Web Server, IIS, NginX 등이 있습니다.  
    
    \- **1) 소프트웨어**    
      \- 웹 브라우저의 요청을 받아들여서 이에 알맞은 결과를 웹 브라우저에 응답해주는 역할입니다.   
      \- 정적인 처리 및 가벼운 동적 리소스 제공 역할을 합니다.  
      \- 요청에 따라 필요한 페이지의 로직이나 데이터베이스 연동을 위해서 애플리케이션 서버에 처리를 요청합니다.  
      \- Reverse Proxy 보안 기능, 로드 밸런싱 다수 User 분산 처리, 캐싱 등 보안 및 트래픽 처리를 담당합니다.  
      
    \- **2) 하드웨어**   
      \- Web Server가 설치되어 있는 컴퓨터 

  - **WAS(Web Application Server)**   
    \- 웹브라우저로부터 웹 서버가 요청을 받으면 그 요청을 받아 로직 처리의 결과를 웹 서버로 다시 반환해주는 소프트웨어입니다.   
    \- 웹 서버와 DBMS 사이에 동작하는 미들웨어로써, 컨테이너 기반으로 동작합니다.   
    \- 흔히 컨테이너, 웹 컨테이너, 서블릿 컨테이너로 부릅니다.    
    \- 대표적인 예로 Apache Tomcat, Jetty(Eclipse), WEbLogic(Oracle), Jeus(WebToB), JBoss(Red Hat) 등이 있습니다.     
    
    ##### **[`+여기서 잠깐`]() 컨테이너란?**     
        - JSP, Servlet을 실행시킬 수 있는 소프트웨어    
       
    ##### **[`+여기서 잠깐`]() 웹 컨테이너란?**    
        - 클라이언트 요청을 내부 로직을 통해 결과를 처리하고 동적 컨텐츠를 생성해 클라이언트에게 응답 해주는 역할을 수행.      
</br>


### :heavy_check_mark: **MVC1 vs MVC2**  

  - **MVC란?**     
    \- Model-View-Controller의 약자로 3가지 형태로 역할을 나누어 개발하는 방법론입니다.  
    \- 사용자 인터페이스와 비지니스 로직 처리를 분리시켜 서로 영향 없이 개발하기 수월하다는 장점이 있습니다.  
    
    ##### **[`+여기서 잠깐`]() Model(저장)**  
        - 어플리케이션에서 처리된 데이터, 자료를 의미합니다.  
        - DB에서 처리된 결과 데이터를 가진 객체입니다.  

    ##### **[`+여기서 잠깐`]() View(표현)**  
        - 사용자가 보게 될 결과 화면으로 유저 인터페이스(UI)를 의미합니다.   
        - 클라이언트 측 기술인 html,css,js 등을 모아둔 컨테이너 입니다.  

    ##### **[`+여기서 잠깐`]() Controller(처리)**    
        - Model과 View를 이어주는 브릿지 역할을 의미합니다.  
        - 사용자가 접근한 URL에 따른 요청사항을 처리 후, Model에서 나온 결과 데이터를 View에 반영하여 사용자에게 알려줍니다.  
  
  - **MVC1**  
    \- 모든 요청과 응답을 jsp가 담당하는 구조입니다.  
    \- jsp페이지 안에서 모든 정보를 표현(view), 처리(Controller), 저장(Model)합니다.  
    \- 복잡해지면 유지보수에 용이하지 않습니다.   
    
  - **MVC2**   
    \- 클라이언트 요청을 Servlet이 받아 알맞게 처리 후, jsp페이지로 결과를 전달합니다.  
    \- 클라이언트의 요청, 비니지스 로직 처리, 응답 부분을 모듈화한 구조입니다.  
    \- 처리작업의 분리로 유지보수 및 확장에 용이하지만, 구조 설계를 위한 시간이 필요합니다.  
</br>

### :heavy_check_mark: **Framework**  
- 어떤 프로그램을 만들기 위한 기본 구조(뼈대, 틀) 이라고 합니다.  
- 기본적으로 필요한 기능을 갖추고 있어 개발에 용이합니다.  

  ##### **[`+여기서 잠깐`]() Framework와 Library 차이는?**  
      - Framework : 내가 개발하기 위해 지켜야 하는 구조  
      - Library : 내가 개발하기 위해 필요한 것들이 이미 구현되어 있는 대상  
</br>

### :heavy_check_mark: **Spring Framework**  
- 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 어플리케이션 프레임워크   
</br>

### :heavy_check_mark: **DI(Dependency Injection)**   
- 각 객체 간의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 매핑시켜줍니다. 
- 필요한(의존하는) 클래스를 직접 생성하는 것이 아닌, 주입해줌으로써 객체 간의 결합도를 줄이고 좀 더 유연한 코드를 작성할 수 있게됩니다. 

  ##### **[`+여기서 잠깐`]() 스프링을 통한 의존성 주입**  
      - @Autowired type과 id 중에 type의 매칭 우선순위가 높다. (자바 표준 어노테이션)  
      - @Resource type과 id 중에 id의 매칭 우선순위가 높다. (스프링 프레임워크 어노테이션)  
      - 설정파일을 쓰는 가장 중요한 이유는 재컴파일/재배포 없이 프로그램의 실행 결과를 변경할 수 있기 때문이다.  
      - <property>태그 > @Resource > @Autowired 유지보수 용이한 순서.  
      - DI는 외부에 있는 의존 대상을 주입하는 것.  
</br>

### :heavy_check_mark: **JSON 타입**  
  - **JSON(JavaScript Object Notation)**  
    \- 키-값이 쌍으로 이루어진 개방형 표준 데이터 포맷입니다. (데이터 교환 형식)         
    \- 비동기 브라우저/서버 통신(ajax)을 위해 사용하는 데이터 포맷입니다.   
    \- JavaScript에서 ajax 비동기 통신시 xmlHTTPRequest에 json형태의 데이터로 객체에 담아서 보냄     
    \- 보통 RESTful API, Open API 에서 json 형태의 데이터를 주고 받습니다.      
    `정리` key-value 형식으로 데이터를 주고 받을 때 사용하는 데이터 포맷 형식입니다. {"key" : "value"}  

    ##### [`+여기서 잠깐`]() ajax란?  
        - 페이지 새로고침 없이 서버에 요청을 할 수 있습니다.  
        - 서버로부터 데이터를 받고 작업을 수행할 수 있습니다. 
      
    ##### [`+여기서 잠깐`]() RESTful API란?  
</br>

### :heavy_check_mark: **JavaScript와 jQuery 차이점**   

  - **JavaScript 구성요소**  
    \- 자바스크립트 core 문법  
    \- 자바스크립트 core 라이브러리  
    \- 자바스크립트 BOM(Browser Object Model)  
    \- 자바스크립트 DOM(Document Object Model)  

  - 제이쿼리는 자바스크립트DOM작업을 쉽게 도와주는 라이브러리 입니다.
</br> 


## NETWORK

### :heavy_check_mark: **HTTP vs HTTPS 차이는** 

  - **HTTP(Hyper Text Transfer Protocol)**     
    \- 클라이언트와 서버 사이에 데이터를 주고 받는 프로토콜(통신규약) 입니다.(80번 포트 사용) 
    
  - **HTTPS (Hyper Text Transfer Protocol Secure)**        
     \- HTTP에 데이터 암호화가 추가된 프로토콜 입니다.(433번 포트 사용) 
  
  - **HTTP와 HTTPS 차이?**  
     \- HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면에 HTTPS는 안전하게 데이터를 주고 받을 수 있습니다.     
     \- HTTPS를 이용하면 암호화/복호화의 과정이 필요로 하며, 공개키/개인키 인증서를 발급하고 유지하기 위한 추가 비용이 발생합니다.    

     ##### **[`+여기서 잠깐`]() HTTPS 사용하는 이유?**      
        - HTTP는 암호화 되지 않은 평문 데이터를 전송하기 때문에 개인정보를 주고 받으면 제 3자가 정보를 알 수 있게 됩니다.  
        - 문제 해결을 위해 네트워크 상 중간에 제 3자가 정보를 볼 수 없게 공개키 암호화를 지원하는 SSL프로토콜을 사용합니다. 

     ##### **[`+여기서 잠깐`]() SSL(Secure Socket Layer) 프로토콜**  
        - 브라우저와 서버 사이에 전송된 데이터를 암호화하여 인터넷 연결에 보안성을 유지해주는 기술입니다.  
        - 클라이언트와 서버간 공유하는 암호화키를 가지고 암호회된 데이터가 송수신 되는 방식  
</br>

## DATABASE

### :heavy_check_mark: **RDBMS vs NoSQL 차이는** 
- 핵심적인 2가지 차이가 있습니다.

  - **1. 스키마 유무(데이터 넣는 기준)**     
    \- 관계형 db로 스키마 존재로 스키마 형식에 따라 데이터를 넣어야 하며,  
    \- NoSQL는 스키마가 없기때문에 언제든지 새로운 '필드'를 추가하고 조정 가능하여 확장성에 용이합니다.  
    
   - **2. 스케일링 비교(서버)**     
    \- scale up(수직확장)으로 데이터베이스 서버의 성능을 향상 시키는 것.      
    \- scale out(수평 확장)으로 여러대의 서버를 추가해서 데이터베이스가 전체적으로 분산됨을 의미합니다. 하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동을 합니다.  

   - **장단점**   
    \- **RDBMS** : 명확한 스키마로 데이터 무결성을 보장하고 관계를 통해 각 데이터를 중복없이 저장할 수 있음.  
    \- 상대적으로 덜 유연하며, 데이터 스키마를 변경할 때 risk가 존재합니다.  
    \- join문으로 쿼리가 상당히 복잡해지고 성능향상에 한계때문에 성장 한계가 존재.  
    \- **NoSQL** : 스키마가 없기때문에 유연성이 높고 필요한 형식을 바로 추가할 수 있고  
    \- 데이터를 가져오는 속도가 빨라진다.  
    \- 유연성 때문에 구조 결정이 늦어질 수 있고, 복사된 데이터가 변경되면 여러 콜렌션 및 문서를 수정해야 합니다.  
</br> 

### :heavy_check_mark: **DB 인덱스?**  
- 접근 경로를 제공하여 어디 어떤 데이터가 있다는 것을 알려줍니다.    
- 검색 속도를 향상시키기 위한 자료구조 입니다.  
</br> 

## 자료구조

### :heavy_check_mark: **순차 자료구조 vs 연결 자료구조**

   - **데이터 삽입**   
    \- 순차 자료구조의 마지막에 데이터를 삽입하는 경우는 빠르지만, 처음과 중간에 삽입하는 경우 자리교환으로 오버페드가 발생하여 느립니다.  
    \- 연결 자료구조는 데이터를 어디에 삽입하던 해당 위치까지 엑세스하는 시간만 소요되지만, 자료 추가시 링크만 교체하면 되므로 빠릅니다.  
    
   - **데이터 읽기**      
    \- 순차 자료구조는 탐색하려는 위치를 알고 있다면 즉시 액세스 할 수 있으므로 빠릅니다.  
    \- 연결 자료구조는 위치를 알던 모르던 관계없이 헤더부터 찾으려는 위치까지 탐색해야 하므로 느립니다. 

### :heavy_check_mark: **스택(Stack)과 큐(Queue)**   
  - 데이터가 담기고 나오는 순서가 다릅니다.  
  - 스택과 큐는 **선형자료구조**로 데이터가 1:1 연결되어 있습니다.
  - 스택은 FILO, LIFO으로 PUSH, POP  
  - 큐는 FIFO으로 ENQUEUE, DEQUEUE  
    
### :heavy_check_mark: **트리(Tree)과 그래프(Graph)**   
  - 트리와 그래프는 **비선형자료구조**로 데이터가 1:N, N:N 연결되어 있습니다.  
  - 트리와 그래프는 순환여부의 차이가 있습니다.   
  - 트리는 순환이 안되고, 그래프는 순환이 됩니다.  
  - 즉, 그래프에는 루트 노드가 존재하지 않고, 트리는 루트 노드로 돌아오는 에지가 존재하지 않습니다.  
    
### :heavy_check_mark: **힙(Heap)**  
  - 트리구조 중에 하나로 Binary Tree입니다.  
  - 완전이진탐색트리 일종으로 자식 노드가 최대 2개이며, 최대값, 최소값을 빠르게 찾기위한 연산방식입니다.
      
### :heavy_check_mark: **깊이 우선 탐색(DFS, Depth First Search)**   
  - stack 구현, 자식노드 즉, 하위레벨부터 탐색합니다. 

### :heavy_check_mark: **너비 우선 탐색(BFS, Breadth First Search)**   
  - Queue 구현, 형제노드 즉, 동등레벨부터 탐색합니다. 
    
### :heavy_check_mark: **해쉬(Hash)**
  - 데이터를 저장하는 방식 중에 하나로 hash 함수를 통해서 저장하는 방식입니다.
  - hash 함수에서 나온 값을 주소지로 사용해서 저장하는 방식. 
  - 시간적인 측면에서 이점이 있습니다. 
  - 보통은 데이터 탐색시간이 for문을 다 돌려서 찾으므로 오래걸리지만  (자료개수만큼 O(n))
  - 해쉬함수는 해당 주소로 접근하기때문에 비교적 시간이 잛게 걸립니다.
  - 시간 복잡도 O(1) 빅-오 표기법
