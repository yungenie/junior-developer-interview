# :pencil2: 주니어 개발자 면접 준비
</br>

### :heavy_check_mark: **HTTP Server vs WAS(Web Application Server)**

  - **HTTP Server(Web server)**   
    \- 일반적으로 인터넷 브라우저를 통해 HTTP를 사용하여 클라이언트 컴퓨터와 통신하는 서버입니다.     
    \- 클라이언트의 웹브라우저로부터 HTTP 요청을 받아 정적인 컨텐츠(.html, .css, .js, .jpng, .png 등)를 제공하는 컴퓨터 프로그램.  
 
     ##### **[`+여기서 잠깐`]() HTTP와 HTTPS 차이는?**    
        - HTTP(Hyper Text Transfer Protocol): 클라이언트와 서버 사이에 데이터를 주고 받는 프로토콜(통신규약) 입니다.(80번 포트 사용)  
        - HTTPS (Hyper Text Transfer Protocol Secure): HTTP에 데이터 암호화가 추가된 프로토콜 입니다.(433번 포트 사용)  
        - HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면에 HTTPS는 안전하게 데이터를 주고 받을 수 있습니다.  
        - HTTPS를 이용하면 암호화/복호화의 과정이 필요로 하며, 공개키/개인키 인증서를 발급하고 유지하기 위한 추가 비용이 발생합니다.  

    ##### **[`+여기서 잠깐`]() HTTPS 사용하는 이유?**      
        - HTTP는 암호화 되지 않은 평문 데이터를 전송하기 때문에 개인정보를 주고 받으면 제 3자가 정보를 알 수 있게 됩니다.  
        - 문제 해결을 위해 네트워크 상 중간에 제 3자가 정보를 볼 수 없게 공개키 암호화를 지원하는 SSL프로토콜을 사용합니다. 

    ##### **[`+여기서 잠깐`]() SSL(Secure Socket Layer) 프로토콜**  
        - 브라우저와 서버 사이에 전송된 데이터를 암호화하여 인터넷 연결에 보안성을 유지해주는 기술입니다.  
        - 클라이언트와 서버간 공유하는 암호화키를 가지고 암호회된 데이터가 송수신 되는 방식  
</br>

### :heavy_check_mark: **MVC1 vs MVC2**  

  - **MVC란?**     
    \- Model-View-Controller의 약자로 3가지 형태로 역할을 나누어 개발하는 방법론입니다.  
    \- 사용자 인터페이스와 비지니스 로직 처리를 분리시켜 서로 영향 없이 개발하기 수월하다는 장점이 있습니다.  
    
    ##### **[`+여기서 잠깐`]() Model(저장)**  
        - 어플리케이션에서 처리된 데이터, 자료를 의미합니다.  
        - DB에서 처리된 결과 데이터를 가진 객체입니다.  

    ##### **[`+여기서 잠깐`]() View(표현)**  
        - 사용자가 보게 될 결과 화면으로 유저 인터페이스(UI)를 의미합니다.   
        - 클라이언트 측 기술인 html,css,js 등을 모아둔 컨테이너 입니다.  

    ##### **[`+여기서 잠깐`]() Controller(처리)**    
        - Model과 View를 이어주는 브릿지 역할을 의미합니다.  
        - 사용자가 접근한 URL에 따른 요청사항을 처리 후, Model에서 나온 결과 데이터를 View에 반영하여 사용자에게 알려줍니다.  
  
  - **MVC1**  
    \- 모든 요청과 응답을 jsp가 담당하는 구조입니다.  
    \- jsp페이지 안에서 모든 정보를 표현(view), 처리(Controller), 저장(Model)합니다.  
    \- 복잡해지면 유지보수에 용이하지 않습니다.  
    
  - **MVC2** 
    \- 클라이언트 요청을 Servlet이 받아 알맞게 처리 후, jsp페이지로 결과를 전달합니다.
    \- 클라이언트의 요청, 비니지스 로직 처리, 응답 부분을 모듈화한 구조입니다.
    \- 처리작업의 분리로 유지보수 및 확장에 용이하지만, 구조 설계를 위한 시간이 필요합니다.


### :heavy_check_mark: **Framework**  
- 어떤 프로그램을 만들기 위한 기본 구조(뼈대, 틀) 이라고 합니다.  
- 기본적으로 필요한 기능을 갖추고 있어 개발에 용이합니다.  

  ##### **[`+여기서 잠깐`]() Framework와 Library 차이는?**  
      - Framework : 내가 개발하기 위해 지켜야 하는 구조  
      - Library : 내가 개발하기 위해 필요한 것들이 이미 구현되어 있는 대상  
</br>

### :heavy_check_mark: **replaceAll("[a-zA-Z]","").toUpperCase()**
  - **\[a-zA-Z]\(정규식)**   
    \- a-z, A-z까지 정규표현식(Regex)
    
  - **toUpperCase()**    
    \- toUpperCase() 메서드는 문자열을 대문자로 변환한 값을 반환합
</br>

### :heavy_check_mark: **extends vs implement**  
  - **extends(상속)**     
    \- extends 키워드를 사용하여 부모 클래스를 상속받아 자식 클래스에서 부모 클래스가 가진 것을 사용할 수 있습니다.  
    \- 부모가 가진 것을 자식에게 물려주는 것을 is a 혹은 kind of 관계라고 부릅니다.  
 
  - **implement(구현)**  
    \- 인터페이스를 상속받아 기능을 재정의(Overriding)하는 것입니다.
</br>

### :heavy_check_mark: **Call by Value vs Call by Reference**  
  - **Call by Value**   
    \- 값에 의한 호출을 의미합니다.   
    \- 전달받은 값을 복사하여 처리하기 때문에 전달받은 값이 변경되어도 원본의 값이 변경되지 않습니다.  
    `정리` Call by value는 메서드 호출 시에 사용되는 인자 값의 메모리에 저장된 값(value)을 복사하여 보낸다.
    
  - **Call by Reference**   
    \- 참조에 의한 호출을 의미합니다.   
    \- 전달받은 값을 직접 참조하기 때문에 값이 변경되면 원본도 같이 변경됩니다.   
    `정리` Call by reference는 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어있는 주소(Address)를 복사하여 보낸다.    
</br>

### :heavy_check_mark: **Session vs Cookie**   

  - **Session와 Cookie 사용 이유?**       
      \- HTTP의 비연결성(Connectionless)와 무상태(Stateless)이라는 특징을 보안하기 위해 사용합니다.   
      `정리` **클라이언트의 정보를 유지**하기 위해 사용하는 것이 쿠키와 세션입니다.    
      
    ##### **[`+여기서 잠깐`]() 비연결성(Connectionless)**   
        - HTTP는 클라이언트가 요청(Request)을 보내고, 서버는 클라이언트에게 응답(Response)을 주면 연결을 끊는 특성이 있습니다.  

    ##### **[`+여기서 잠깐`]() 무상태(Stateless)**     
        - 연결을 끊는 순간 클라이언트와 서버의 통신도 끝나며, 상태 정보를 유지하지 않는 특성이 있습니다.  
      
  - **Cookie(쿠키)**   
    \- 사용자에 대한 정보를 접속자 PC에 저장합니다.    
    \- 사용자 인증 유효 시간이 정해지면 브라우저를 종료되어도 인증이 유지된다.  
    \- 사용자 로컬 PC에 저장되는 키와 값(Key, Value)이 들어있는 작은 데이터 파일입니다.   
    \- 세션 쿠키(Session Cookie)와 지속 쿠키(Persistent Cookie)로 나뉩니다.    

    ##### **[`+여기서 잠깐`]() 세션 쿠키(Session Cookie)**     
        - 유효시간을 지정하지 않으면 브라우저 메모리에 저장되므로, 브라우저가 종료되면 쿠키는 사라집니다. 

    ##### **[`+여기서 잠깐`]() 지속 쿠키(Persistent Cookie)**  
        - 유효시간을 지정하면 파일로 저장되어 특정 날짜(기간)까지 유효하므로, 브라우저가 종료되어도 쿠키는 남아 있습니다.   
        
    ##### **[`+여기서 잠깐`]() 구성 요소**    
        - 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름    
        - 값 : 쿠키가 갖고 있는 값    
        - 유효시간 : 쿠키가 유지되는 시간    
        - 도메인 : 쿠키를 전송할 도메인    
        - 경로 : 쿠키를 전송할 요청 경로    
         
    ##### **[`+여기서 잠깐`]() Cookie 동작 방식?**  
        1. 클라이언트가 웹 페이지를 요청합니다. 
        2. 웹 서버는 Session ID를 발급합니다.
        3. 생성한 쿠키에 정보를 담아 HTTP화면을 돌려줄 때, 같이 클라이언트에게 돌려줍니다.
        4. 넘겨 받은 쿠키를 클라이언트 로컬 PC의 쿠키 저장소에 저장합니다. (이때 쿠키 이름 JSESSIONID) 
        5. 다시 웹 서버에 요청할 때 요청과 함께 Request-Header에 쿠키 값을 넣어 전송합니다.
  
    ##### **[`+여기서 잠깐`]() Cookie 사용 예시?**    
        - 방문 사이트 로그인 시, "자동 로그인" , "아이디와 비밀번호를 저장하시겠습니까?"  
        - 팝업창에서 "오늘 더 이상 이 창을 보지 않음" 체크     
        - 쇼핑몰 장바구니 기능    
        
  - **Session(세션)**  
    \- 세션은 쿠키를 기반으로, 사용자에 대한 정보를 **웹 서버 측에 저장**합니다.  
    \- 사용자에 대한 정보를 웹 서버에 두기 때문에 **보안면에서는 쿠키보다 우수**합니다.    
    \- 클라이언트를 구분하기 위해 Session ID를 부여하여 **브라우저가 종료할 때까지 인증 상태를 유지**해줍니다.    
    \- 단, **접속 시간에 제한**을 두어 일정 시간 응답이 없으면 연결을 끊도록 설정 가능합니다.  
    
    ##### [`+여기서 잠깐`]() Session 동작 방식?
        1. 클라이언트가 웹 페이지에 요청합니다.
        2. 클라이언트가 요청한 Request-Header에 Cookie 확인하여 Session ID 유무를 확인합니다.
        3. Session ID가 존재하지 않다면, Session ID를 생성해 클라이언트로 돌려줍니다.
        4. 클라이언트로 돌려줄 때, Response-Header의 Cookie에 Session ID를 저장해서 보냅니다.
        5. 클라이언트는 Session ID를 Cookie 저장소에 저장합니다. (이때 쿠키 이름 JSESSIONID) 
        6. 클라이언트가 서버에 다시 접속 시 Request-Header의 Cookie(JSESSION)를 이용하여 Session ID값을 서버에 전달합니다.

    ##### [`+여기서 잠깐`]() Session 사용 예시? 
        - 화면을 이동해도 로그인이 유지됩니다.        
        
   - **Session와 Cookie 차이점**      
      \- **클라이언트의 정보가 저장되는 위치, 저장형식, 만료시점 등**이 다릅니다.  
      `정리` 저장 위치 : 쿠키는 클라이언트의 브라우저 메모리에 저장 또는 파일에 저장하고, 세션은 서버 메모리에 저장합니다.   
      `정리` 만료 시점 : 쿠키는 정해진 사용자 유효 시간까지 브라우저 인증 유지, 세션은 접속 시간에 따른 일정한 시간에 응답이 없으면 연결을 끊습니다. 
</br> 
      
### :heavy_check_mark: **JSON 타입**  
  - **JSON(JavaScript Object Notation)**  
    \- 키-값이 쌍으로 이루어진 개방형 표준 데이터 포맷입니다. (데이터 교환 형식)         
    \- 비동기 브라우저/서버 통신(ajax)을 위해 사용하는 데이터 포맷입니다.   
    \- JavaScript에서 ajax 비동기 통신시 xmlHTTPRequest에 json형태의 데이터로 객체에 담아서 보냄     
    \- 보통 RESTful API, Open API 에서 json 형태의 데이터를 주고 받습니다.      
    `정리` key-value 형식으로 데이터를 주고 받을 때 사용하는 데이터 포맷 형식입니다. {"key" : "value"}  

    ##### [`+여기서 잠깐`]() ajax란?  
        - 페이지 새로고침 없이 서버에 요청을 할 수 있습니다.  
        - 서버로부터 데이터를 받고 작업을 수행할 수 있습니다. 
      
    ##### [`+여기서 잠깐`]() RESTful API란?   
      
